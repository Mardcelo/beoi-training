\documentclass[12pt]{beamer}
\usepackage{listings}
\usepackage[]{color}
\beamertemplatenavigationsymbolsempty
\AtBeginSection[]
{
    \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
    \end{frame}
}
\lstset{language=C++, basicstyle=\footnotesize}
\setlength{\tabcolsep}{10pt}
\newcommand{\bigoh}{\mathcal{O}}

\title{Segment Tree and Lazy Propagation}
% \subtitle{DFS, BFS, applications}
\author{beOI Training}
\institute{\includegraphics[height=12em]{../share/beoi-logo}}

\begin{document}

\frame{\titlepage}

\section{Regular Segment Tree}

\begin{frame}

\frametitle{Motivating problem}

You are given an integer array $A$ of size $n$ ($n < 10^6$).\\
Given two integers $a$ and $b$, can you give the sum of the entries in $A$ between indices $a$ and $b$ ?
\[
    A[a] + \ldots + A[b-1]
\]

Well that's easy, just iterate over the interval and sum!

\end{frame}

\begin{frame}

\frametitle{Motivating problem}

You are given an integer array $A$ of size $n$ ($n < 10^6$).\\
Given two integers $a$ and $b$, can you give the sum of the entries in $A$ between indices $a$ and $b$ ?
\[
    A[a] + \ldots + A[b-1]
\]

\begin{center}
\huge{100000 times?} 
\end{center}

This is called the \textbf{range sum query} (RSQ) problem.

\end{frame}

\begin{frame}
    \frametitle{Naive solution}
    For each query, iterate over the corresponding range and sum the entries. \\
    If $k$ is the number of queries, time complexity is $\bigoh(nk)$. \\
    \textcolor{blue}{TLE}
\end{frame}

\begin{frame}
    \frametitle{Array representation of a binary tree}
    \begin{itemize}
        \item 0-based array, index 0 = root
        \item For each node of index $p$,
        \begin{itemize}
            \item left child has index $2p+1$
            \item right child has index $2p+2$
        \end{itemize}
    \end{itemize}
    \begin{center}
        \includegraphics[width=.5\textwidth]{img/compact-array.png}
    \end{center}
\end{frame}

\begin{frame}
    \frametitle{Segment Tree}
    Each node is responsible of one segment \\
    Root represents the whole array $[0, n[$ \\
    Given a node representing segment $[l, r[$ 
    \begin{itemize}
        \item left child represents the segment's first half $\left[ l, \frac{l+r}{2} \right[$
        \item right child represents the segment's second half $\left[ \frac{l+r}{2}, r \right[$
    \end{itemize}
    The value of a node will be the \textbf{sum of the entries in segment $\left[ l, r \right[$}.

\end{frame}

\begin{frame}
    \frametitle{Querying}
    When we query the sum in an interval, we look for \textbf{big segments that are contained within the query range}, and sum their values. \\
    Recursively,
    \begin{itemize}
        \item segment is within query range $\Rightarrow$ return value of the node;
        \item segment and query range are disjoint $\Rightarrow$ do nothing;
        \item otherwise, return sum of both children.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Querying implementation}

    \lstinputlisting{src/query.cpp}
\end{frame}

\begin{frame}
    \frametitle{Querying complexity}

    At each level, at most 4 nodes are visited (see coach for proof). \\
    There are exactly $\lceil \log_2 n \rceil$ levels.
    \[
        \bigoh(4\times \lceil \log_2 n \rceil) = \bigoh(\log n)
    \]
    Overall complexity $\bigoh(k \log n)$ is now reasonable! \\
    \textcolor{green}{AC}
\end{frame}

\begin{frame}
    \frametitle{Building}
    Building the Segment Tree is also done recursively. \\
    For each node,
    \begin{itemize}
        \item if no child, store current value;
        \item otherwise,
            \begin{itemize}
                \item build left child;
                \item build right child;
                \item store sum of children.
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Building implementation}
    \lstinputlisting{src/build.cpp}
\end{frame}

\begin{frame}
    \frametitle{Building complexity}
    We visit every node once. \\
    In general, the number of nodes is $ N + \frac{N}{2} + \frac{N}{4} + \cdots + 2 + 1 \approx 2N $, so time complexity is
    \[ \bigoh(2\times N) = \bigoh(N) \]
    This also proves memory is $ \bigoh(N) $ (in practice one always takes an array of $4\times N$ for safety).
\end{frame}

\begin{frame}
    \frametitle{Segment Trees are extremely powerful!}
    We saw how to solve the range \textbf{sum} query problem.\\
    But we can do much more than that! \\
    \begin{itemize}
        \item Range minimum query
        \item Range maximum query
        \item Range *insert any function here* query
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{One last operation}
    Suppose that, between queries, the array is being \textbf{updated}.\\
    Naive solution: re-build the Segment Tree in $ \bigoh(N) $. \\
    \textcolor{blue}{TLE} \\
    Segment Trees allow efficient \textbf{updating}!
\end{frame}

\begin{frame}
    \frametitle{Updating}
    To update $p$, we only need to update the segments that contain $p$. \\
    Update the leaf to root path in $ \bigoh(\log N) $!
\end{frame}

\begin{frame}
    \frametitle{Updating implementation}
    \lstinputlisting{src/update.cpp}
\end{frame}

\section{Lazy Segment Tree}

\begin{frame}
    \frametitle{Motivating problem}
    In the Range Sum Query (RSQ) problem, we add one operation: range update. \\
    We want to update a range (e.g. increment every value in range by $dx$) efficiently.
\end{frame}

\begin{frame}
    \frametitle{Naive solution}
    At each range update query, re-build tree in $\bigoh(N)$. \\
    \textcolor{blue}{TLE}
\end{frame}

\begin{frame}
    \frametitle{Let's be lazy!}
    Key idea behind lazy Segment Tree: don't update everything at once; put a flag on segments that need to be updated, and leave it for another traversal. \\
\end{frame}

\begin{frame}
    \frametitle{Propagation}
    Keep an array \lstinline{lazy} that stores for each segment by how much each value needs to be incremented. \\
    Every time we visit a node $p$ (in \lstinline{query} or \lstinline{update}) where \lstinline{lazy[p] != 0},
    \begin{itemize}
        \item increment current segment by \lstinline{lazy[p]} times size of segment;
        \item if node is not leaf,
            \begin{itemize}
                \item increment \lstinline{lazy[2*p+1]} by \lstinline{lazy[p]}
                \item increment \lstinline{lazy[2*p+2]} by \lstinline{lazy[p]}
            \end{itemize}
        \item reset \lstinline{lazy[p]}.
    \end{itemize}
    That is called \textbf{propagation}. \\
    Obviously, complexity is $\bigoh(1)$.
\end{frame}

\begin{frame}
    \frametitle{Propagation implementation}
    \lstinputlisting{src/propagation.cpp}
\end{frame}

\begin{frame}
    \frametitle{Querying}
    We do exactly the same, but we propagate at each node! \\
    Complexity $\bigoh(\log N)$.

\end{frame}

\begin{frame}
    \frametitle{Querying implementation}
    \lstinputlisting{src/lazy-query.cpp}
\end{frame}

\begin{frame}
    \frametitle{Updating}
    For each node, 
    \begin{itemize}
        \item propagate
        \item if outside of range, return
        \item if inside of range, set the lazy flag, and return
        \item otherwise
            \begin{itemize}
                \item update left child
                \item update right child
            \end{itemize}
        \item merge both children (add them up)
    \end{itemize}
    Complexity $\bigoh(\log N)$.
\end{frame}

\begin{frame}
    \frametitle{Updating implementation}
    \lstinputlisting{src/lazy-update.cpp}
\end{frame}

\section{Other Topics}

\begin{frame}
    \frametitle{Segment Trees are extremely powerful! (part 2)}
    Many combinations of queries and updates can be solved with segment trees!
    \begin{itemize}
        \item Range minimum query with \lstinline{+= dx} updates: minimum position does not change in the interval.
        \item Range sum query with \lstinline{*= product} updates: sum over interval is multiplied by \lstinline{product}.
        \item And so on...
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Iterative segment trees}

    \begin{itemize}
        \item Shorter and more efficient than the recursive segment trees we have seen so far.
        \item My opinion: more difficult to remember, \textbf{not worth it} for IOI.
        \item See: \url{https://codeforces.com/blog/entry/18051}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Fenwick trees}

    \begin{itemize}
        \item Faster to write, but less flexible: operation must be invertible (e.g. RSQ but not RMQ).
        \item Range updates are possible but complicated.
        \item See: \href{https://github.com/be-oi/beoi-training/tree/master/09-fenwick-tree}{09-fenwick-trees}.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{"Dynamic" segment trees}

    \begin{itemize}
        \item What if we cannot fit the entire range in memory?
        \item For example: Range Sum Query on array of size $10^9$, initialized with $0$, but updated later.
        \begin{itemize}
            \item Memory usage: 4 bytes per integer $\times$ $4n$ of storage.
            \item $4 \times 4 \times 10^9 \approx 16$ Gb.
            \item \textcolor{blue}{Memory Limit Exceeded}
        \end{itemize}
        \item Key idea $\Rightarrow$ Use an \lstinline{unordered_map} instead of a \lstinline{vector}, build tree as needed.
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{2D segment trees}

    \begin{itemize}
        \item Key idea $\Rightarrow$ Inside each node of an outer segment tree, store an inner segment tree.
        \item Allows for queries in $\bigoh\left(\log n \times \log n\right)$.
        \item Very complicated to implement.
        \item See also: Game from IOI 2013.
        \item (A quad tree does not work, worst cast complexity is $\bigoh (n)$.)
    \end{itemize}
\end{frame}

\end{document}
